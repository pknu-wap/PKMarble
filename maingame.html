<!DOCTYPE html>
<html>

<head>
    <title>horol</title>
    <meta charset="utf-8">
</head>

<body>
    <script src="./js/object.js"></script>
    <script type="text/javascript">
    var player_turn = 0;
    var sum_of_turn = 1;

    function start_turn(player) {
        alert("현재 플레이어 " + (player + 1) + " 턴 입니다.");
        console.log(player + 1 + " 턴 입니다.");
        if (players[player].bus) {
            bus(player);
        } else if (players[player].festival) {
            festvial(player);
        } else {
            throw_dice(player);
        }
    }

    function throw_dice(player) {
        var dice = random(1, 12);
        console.log("dice : " + dice);
        playermove(player, dice);
    }

    function random(min, max) {
        var ranNum = Math.floor(Math.random() * (max - min + 1)) + min;
        return ranNum;
    }

    function playermove(player,
        dice) {
        var player_cell = players[player].cell;
        var player_line = players[player].line;
        player_cell += dice;
        console.log("players[player].cell : " + player_cell);
        if (player_cell > 7 && player_cell <= 14) {
            player_line++;
            player_cell -= 7;
            if (player_line > 4)
                player_line = 1;
        } else if (player_cell > 14 && player_cell <= 21) {
            player_line += 2;
            player_cell -= 14;
            if (player_line > 4)
                player_line = 1;
        }

        players[player].cell = player_cell;
        players[player].line = player_line;
        console.log("players[player].cell : " + players[player].cell);
        console.log("players[player].line : " + players[player].line);
        check_current_board_cell(player);
    }

    function check_current_board_cell(player) {
        var building_number = (players[player].cell + (players[player].line - 1) * 7) - 1;
        console.log("building_number : " + building_number);
        console.log("special_building : " + build[building_number].special_building);
        if (!build[building_number].special_building) {
            if (build[building_number].owner != players[player].id && build[building_number].owner != 0) {
                cost_entrancefee(player, building_number);
            } else {
                if (build[building_number].buildings == 4) {
                    alert("랜드마크를 건설했으므로 더이상 건설이 불가능합니다!!");
                    end_turn();
                } else {
                    construct_building(player, building_number);
                }
            }
        } else {
            // 특수 건물 경우를 넣어주는 부분
            var building_name = build[building_number].name;
            switch (building_name) {
                case "START":
                    players[player].money += 1000000;
                    construct_building(player, building_number);
                    break;
                case "미래관":
                    get_money(player);
                    break;
                case "대학휴학":
                    alert("한 턴 스킵됩니다.");
                    end_turn();
                    break;
                case "호연관":
                    //향파관 이동
                    players[player].line = 4;
                    players[player].ceil = 4;
                    end_turn();
                    break;
                case "대학축제":
                    //모든 소유 건물 통행료 1.2배
                    festival(player);
                    break;
                case "수위실":
                    // 돈 10퍼센트 압수
                    rob_money(player, 0.1, 16);
                    break;
                case "환경해양관":
                    // 돈 5퍼센트 압수
                    rob_money(player, 0.05, 19);
                    break;
                case "셔틀버스":
                    // 세계 여행
                    players[player].bus = true;
                    end_turn();
                    break;
                case "향파관":
                    //호연관 이동
                    players[player].line = 2;
                    players[player].cell = 5;
                    end_turn();
                    break;
                default:
                    alert("특수 건물 오류 발생");
                    end_turn();
                    break;
            }
        }
    }

    function construct_building(player, building_number) {
        var confirm_build = confirm("건물을 지으시겠습니까??");
        if (confirm_build) {
            var input = prompt("지을 건물 단계를 정해주세요(랜드 마크 건설은 4를 입력해주시면 됩니다. 0은 취소)" +
                "\n현재 건물 단계 : " + build[building_number].buildings +
                "\n1단계 가격 : " + build[building_number].build_cost[0] +
                "\n2단계 가격 : " + build[building_number].build_cost[1] +
                "\n3단계 가격 : " + build[building_number].build_cost[2],
                +"\n랜드 마크 가격 : " + build[building_number].build_cost[3], 0);
            console.log(input);
            switch (input) {
                case '0':
                    //건물을 건설하지 않는다고 했으므로 턴 끝
                    end_turn();
                    break;
                case '1':
                case '2':
                case '3':
                    var parse_input = parseInt(input);
                    if (parse_input > build[building_number].buildings) {
                        check_buying_possibility_and_buying(player, building_number, parse_input);
                    } else {
                        alert("현재 건물의 단계보다 높은 값을 입력해주세요.");
                        construct_building(player, building_number);
                    }
                    break;
                case '4':
                    if (build[building_number].buildings == 3) {
                        check_buying_possibility_and_buying(player, building_number, parse_input);
                    } else {
                        alert("현재 건물의 단계가 3이 아니므로 랜드 마크를 지을 수 없습니다.");
                        construct_building(player, building_number);
                    }
                    break;
                case null:
                    alert("건물 짓는 것을 포기했습니다.\n" +
                        "턴이 종료됩니다.");
                    end_turn();
                default:
                    alert("제대로된 값을 입력해주세요");
                    construct_building(player, building_number);
                    break;
            }
        } else {
            end_turn();
            //건물을 건설하지 않는다고 했으므로 턴 끝
        }

    }

    function check_buying_possibility_and_buying(player, building_number, input) {
        var build_cost = build[building_number].build_cost[input]
        if (players[player].money >= build_cost) {
            players[player].assets -= build_cost;
            players[player].money -= build_cost;
            build[building_number].owner = players[player].id;
            build[building_number].buildings = input;
            set_acquisition_cost(building_number);
            //건물 샀음 
            //다음 턴으로 넘어감
        } else {
            alert("현재 돈이 부족합니다.");
            construct_building(player, building_number);
        }
    }

    function cost_entrancefee(player, building_number) {
        //build_cost가 배열이기 때문에 인덱스 값을 취해주기 위해 -1을 함
        var entrancefee = 0;
        var land_owner = build[building_number].owner - 1;
        var current_building_status = build[building_number].buildings - 1;
        console.log(players[player].money);
        console.log(land_owner);
        console.log(current_building_status);
        if (!players[land_owner].festival) {
            entrancefee = build[building_number].build_cost[current_building_status];
        } else {
            entrancefee = build[building_number].build_cost[current_building_status] * 1.2;
        }
        console.log("통행비 : " + entrancefee);

        if (players[player].money >= entrancefee) {
            players[player].money -= entrancefee;
            //통행료를 지불했기 때문에 인수로 넘어감
            acquire_buildings(player, building_number);
        } else {
            if (players[player].assets >= entrancefee) {
                //총 자산이 통행세보다 많을 경우 매각 단계에 돌입
                var confirm_disposal = confirm("현재 보유 중인 현금이 통행세보다 비싸서 땅을 매각 하시겠습니까?\n" +
                    "취소시 파산 처리됩니다.");
                if (confirm_disposal) {
                    disposal_asset(player, building_number);
                } else {
                    end_player(player);
                    //패배 처리 및 턴 종료
                }
            } else {
                if (!players[player].loan) {
                    var confirm_loan = confirm("단 한번 대출을 받을 수 있습니다 받으시겠습니까?\n" +
                        "취소시 파산 처리됩니다.");
                    if (confirm_loan) {
                        players[player].loan = true;
                        players[player].money = 0;
                        players[player].assets = 0;
                        end_turn();
                    } else {
                        end_player(player);
                    }
                } else {
                    end_player(player);
                }
            }
        }
    }

    function acquire_buildings(player, building_number) {
        var acquisition_cost = build[building_number].acquisition_cost;
        console.log("인수 비용 : " + acquisition_cost);
        if (players[player].money >= acquisition_cost) {
            var confirm_acquire = confirm("현재 이 건물을 인수할 수 있습니다. 인수하시겠습니까?");
            if (confirm_acquire) {
                players[player].money -= acquisition_cost;
                players[player].assets += acquisition_cost;
                build[building_number].owner = players[player].id;
                construct_building(player, building_number);
            } else {
                end_turn();
            }

        } else {
            alert("인수할 현금이 부족합니다!");
            end_turn();
        }
    }

    function set_acquisition_cost(building_number) {
        var current_cell_line = build[building_number].line;
        var current_building_status = build[building_number].buildings
        var acquisition_cost = build[building_number].acquisition_cost
        switch (current_cell_line) {
            case 1:
                acquisition_cost = build[building_number].build_cost[current_building_status] * 1.2;
                break;
            case 2:
                acquisition_cost = build[building_number].build_cost[current_building_status] * 1.25;
                break;
            case 3:
                acquisition_cost = build[building_number].build_cost[current_building_status] * 1.25;
                break;
            case 4:
                acquisition_cost = build[building_number].build_cost[current_building_status] * 1.3;
                break;
            default:
                alert("오류가 발생했습니다. 턴을 종료합니다.");
        }
        build[building_number].acquisition_cost = acquisition_cost;
        console.log("인수 비용 set : " + build[building_number].acquisition_cost);
        end_turn();
    }

    function disposal_asset(player, building_number) {
        var parse_input_disposal = parseInt(input_disposal);
        var land = build[parse_input_disposal]
        var seller = players[player].id;
        var input_disposal_land;
        var sum_of_disposal = 0;
        while (players[player].money < build[building_number].acquisition_cost) {
            input_disposal_land = prompt("매각할 땅을 입력해주세요\n" +
                "(땅의 번호를 입력해주세요.)\n" +
                "현재 현금 : " + players[player].money, 0);

            if (parse_input_disposal_land == NaN) {
                alert("제대로된 값을 입력해주세요.");
                continue;
            }

            if (land.owner == seller) {
                players[player].money += land.build_cost[building_number];
                sum_of_disposal += land.build_cost[building_number];
                build[parse_input_disposal].owner = 0;
            } else {
                alert("입력하신 땅은 다른 사람의 소유입니다.");
                continue;
            }
        }
        alert("매각이 완료되었습니다.");
        end_turn();
    }

    function reset_board() {}

    function festival(player) {
        if (players[player].festival) {
            players[player].festival = false;
        } else {
            players[player].festvial = true;
        }
        end_turn();
    }

    function bus(player) {
        if (players[player].bus) {
            var bus_input = prompt("가고 싶은 지역의 번호를 입력해주세요.\n" +
                "(단 띄어 쓰기는 하셔야합니다.)", "1");
            var parse_bus_input = parseInt(bus_input);
            if (parse_bus_input == NaN) {
                alert("제대로 숫자를 입력 해주세요.")
                bus(player);
            }
            players[player].line = build[bus_input - 1].line;
            players[player].cell = build[bus_input - 1].cell;
            players[player].bus = false;
            end_turn();
        }
    }

    function rob_money(player, percent, index) {
        //수위실은 배열 인덱스가 16
        build[3].stack_of_money += players[player].money * percent;
        players[player].money *= (1 - percent);
        alert("현금 자산의 " + percent + "퍼센트가 몰수 당했습니다.");
        end_turn();
    }

    function get_money(player) {
        if (build[3].stack_of_money > 0) {
            build[3].stack_of_money = 0;
            players[player].money += build[3].stack_of_money;
            end_turn();
        } else {
            alert("해당 지역에 쌓인 돈이 없습니다.");
            end_turn();
        }

    }

    function end_turn() {
        sum_of_turn++;
        player_turn++;
        if (player_turn > 3)
            player_turn = 0;
        while (players[player_turn].gameover) {
            player_turn++;
            if (player_turn > 3)
                player_turn = 0;
        }

        console.log("턴 종료 player : " + player_turn);
    }

    function end_player(player) {
        players[player].gameover = true;
        end_turn();
    }

    function check_possibility_to_end_game() {
        var count_player = [0, 0, 0, 0];
        if (sum_of_turn > 30) {

        }
        for (var i = 0; i < 28; i++) {
            if (i < 7) {
                switch (build[i].owner) {
                    case 1:
                        count_player[0] += build[i].owner;
                    case 2:
                        count_player[1] += build[i].owner;
                    case 3:
                        count_player[2] += build[i].owner;
                    case 4:
                        count_player[3] += build[i].owner;
                }
            }
        }
    }
    while (true) {
        start_turn(player_turn);
    }
    </script>
</body>

</html>